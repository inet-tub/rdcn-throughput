import gurobipy as gp
from gurobipy import GRB
import networkx as nx
import numpy as np
import Throughput_as_Function as fct
import Rounding_Draft as rd
import Floor_Draft as fd
import matplotlib.pyplot as plt
def trim_floats(val, tolerance=1e-9):
    if abs(val - round(val)) < tolerance:
        return round(val)
    return val

def generalized_rounding(M, N, d):#Given M, N and d returns rounded numpy matrix sol such that sum of all rows and all columns of sol equal to function parameter d; Assumes d-doubly stochastic matrix 
    model = gp.Model()
    entry_vars = {}
    row_sums = {}
    col_sums = {}
    row_sum_vars = {}
    col_sum_vars = {}
    print(np.array2string(M))
    #Every entry in demand matrix has integer var that is either floor or ceiling
    for i in range(N):
        for j in range(N):
            if i !=j:
                entry_vars[i,j] = model.addVar(vtype=GRB.INTEGER,name=f"entry_{i}_{j}", lb=np.floor(M[i,j]), ub= np.ceil(M[i,j]))
    for i in range(N):
        row_sums[i] = trim_floats(np.sum(M[i,:])) #Necessary to trim sum floats, because otherwise you get 16.000000000004 which can be rounded up -> Not intended
        col_sums[i] = trim_floats(np.sum(M[:,i]))
        row_sum_vars[i] = model.addVar(vtype=GRB.INTEGER,name=f"row_sum_{i}", lb=np.floor(row_sums[i]), ub = np.ceil(row_sums[i]))
        col_sum_vars[i] =  model.addVar(vtype=GRB.INTEGER,name=f"col_sum_{i}", lb=np.floor(col_sums[i]), ub = np.ceil(col_sums[i]))
    print(row_sums)
    print(col_sums)
    #Add row and col constraints
    for i in range(N):
        model.addConstr(gp.quicksum(entry_vars[i,j] for j in range(N) if j !=i) == row_sum_vars[i]) # Row Sum
        model.addConstr(gp.quicksum(entry_vars[j,i] for j in range(N) if j != i) == col_sum_vars[i]) # Col Sum

    model.update()
    const = model.addVar(vtype=GRB.INTEGER, ub=0)
    # diff = model.addVar(vtype=GRB.CONTINUOUS, lb=-1e10 ,ub=1e10) 
    # model.addConstr(gp.quicksum(((entry_vars[i,j] - M[i,j])*entry_vars[i,j]) for i in range(N) for j in range(N) if j != i)== diff)
    #Justification for objective function, which is useful in this case?
    model.setObjective(const, GRB.MAXIMIZE) #Since this is purely a feasibility problem we optimize a constant of 0
    
    # Optimize the model
    model.optimize()
    #Create Rounded Matrix from gurobi variable values and return reference to that matrix
    sol = np.zeros((N,N))
    for i in range(N):
        for j in range(N):
            if i !=j:
                sol[i,j] = entry_vars[i,j].X
    print(np.array2string(sol))
    return sol
def return_normalized_matrix(M): #Normalizes a matrix by dividing it by the scalar which is the biggest row or col sum; Afterwards every row/col sum leq 1 
    max_row_sum = M.sum(axis=1).max()
    max_col_sum = M.sum(axis=0).max()
    max_sum = max(max_row_sum, max_col_sum)
    M = np.divide(M, max_sum)
    print("DONE!")
    print(np.array2string(M))
    return M # call-by-reference doesn't work for some reason, hence returning M
def vermillion_throughput(saturated_demand, d, k, N):
    deg = ((k-1)*N)
    normalized_demand = return_normalized_matrix(saturated_demand)
    scaled_demand = normalized_demand * deg
    rounded_matrix = generalized_rounding(scaled_demand, N, deg)
    out_Left  = []
    in_Left = []
    for row in range(N):
        out_Left.append(int(deg - np.sum(rounded_matrix[row,:])))
    for col in range(N):
        in_Left.append(int(deg - np.sum(rounded_matrix[:,col])))
    print(out_Left)
    print(in_Left)
    G = nx.directed_configuration_model(in_Left, out_Left) #TODO: Re-Check GCM in normal Floor heuristic: Need to use list; not dict!
    # # nx.draw_circular(G, with_labels= True)
    # plt.show()
    for i in range(N):
        print("Node " + str(i) + " has the following edges:")
        for j in range(N):
            if i !=j and G.number_of_edges(i,j) != 0:
                print("To " + str(j) +" : "  + str(G.number_of_edges(i,j)))
    #Do we really NEED to construct another complete graph now?
    total_edge_cap = np.zeros((N,N))
    for i in range(N):
        for j in range(N):
            if i !=j:
                total_edge_cap[i,j] = rounded_matrix[i,j] + G.number_of_edges(i,j) + 1
    total_edge_cap = total_edge_cap *(d /(k*N))
    print(total_edge_cap)
    
    theta = fct.thetaEdgeFormulation(total_edge_cap,saturated_demand, N, input_graph=False )
    return theta
def rotornet_throughput(saturated_demand, d ,N):
    total_edge_cap = np.zeros((N,N))
    for i in range(N):
        for j in range(N):
            total_edge_cap[i,j] = d/N
    return fct.thetaEdgeFormulation(total_edge_cap, saturated_demand,N, False)

if __name__ == "__main__":
    workdir="/home/studium/Documents/Code/rdcn-throughput/matrices/"
    matrices16 = [
                "chessboard-16",
                "uniform-16",
                "permutation-16",
                "skew-16-0.1",
                "skew-16-0.2",
                "skew-16-0.3",
                "skew-16-0.4",
                "skew-16-0.5",
                "skew-16-0.6",
                "skew-16-0.7",
                "skew-16-0.8",
                "skew-16-0.9",
                "data-parallelism","hybrid-parallelism","heatmap2","heatmap3"]
    N = 16
    dE = 8
    k = 2
    filtered_results = []
    for matrix in matrices16:
        loaded_demand = np.loadtxt(workdir+matrix+".mat", usecols=range(N))
        print(np.array2string(loaded_demand))
        eps = 1e-5
        print("_________________________________________________")
        loaded_demand[loaded_demand < eps] = 0 # Filter loaded demand?
        print(np.array2string(loaded_demand))

        filtered_demand = loaded_demand
        saturated_demand = filtered_demand * dE
        filtered_results.append(rotornet_throughput(saturated_demand, dE, N))
    # print("Results for each matrix using Unfiltered Demand and Vermillion with k = " + str(k)) 
    print("Results for each matrix using RotorNet and filtering") 
    for i in range(len(matrices16)):
        print(matrices16[i] + ": " + str(filtered_results[i]))
    # print(np.array2string(normalized_demand))
    # print(normalized_demand.sum(axis=0).max())  #Max Column Sum  
    # print(normalized_demand.sum(axis=1).max())  # Max Row Sum
    # print(max(normalized_demand.sum(axis=0).max(),normalized_demand.sum(axis=1).max()))
    # print(np.array2string(arr))
    # print(arr.sum(axis=0).max())  #Max Column Sum  
    # print(arr.sum(axis=1).max())  # Max Row Sum
    # print(max(arr.sum(axis=0).max(),arr.sum(axis=1).max()))
    
    

    # print(np.array2string(np.floor(arr)))
    # print(max(arr.sum(axis=0).max(),arr.sum(axis=1).max()))
    
    #You need to adapt rounding, st. it corresponds to original row/col sums, not (k-1)*n, 
    
    